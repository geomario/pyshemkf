# Assimilation step in Python for debugging purposes

# import os
# import matplotlib as mpl
import numpy as np
# import exceptions
# from mypackage.plot import plotfunctions as pf
# from mypackage.run import runmodule as rm
# from matplotlib import cm		# Colormap commands (cm.get_cmap())
# import pandas as pd

# Var mit 20, cov mit 19


N = 20
M = 1
n = 2

a = np.array([1.0])
# a = np.array(...).reshape(n, N)

rot = np.array([1.0])
# rot = np.array([...]).reshape(N, N).transpose()

s = np.array([1.0])
# s = np.array([...]).reshape([M, N])

d = np.array([1.0])
# d = np.array([...]).reshape([M, N])

eig = np.array([0.125106E+00])
w = np.array([0.100000E+01])
innov = 0.745124E+00


# Normal EnKF
# ===============

# x3 from eig and d
x3 = eig*d
# reps from a*sT
reps = np.dot(a, s.transpose())

# Damping factor
assidamp = 1.0

# Final update
afin_enkf = a + assidamp*np.dot(reps, x3)


# Sqrt EnKF
# ===============

# meanx5
y1 = np.dot(w.transpose(), innov)
y2 = np.dot(eig, y1)
y3 = np.dot(w, y2)
y4 = np.dot(s.transpose(), y3)

x51 = np.array([y4 for i in range(N)]).transpose()
x5 = (1.0/float(N))*np.ones([N, N]) + x51

# genx2
x21 = np.dot(w.transpose(), s).reshape(M, N)
x2 = np.array([[np.sqrt(eig)[i]*x21[i, j] for j in range(N)]
               for i in range(M)])

# x5sqrt
u, sig, vt = np.linalg.svd(x2)
vt = -vt                                  # Different svd method
isigma = np.array([(np.sqrt(np.max(1.0-sig[i]*sig[i])) if i < M else 1)
                   for i in range(N)])
x31 = vt.transpose()
x3 = np.array([[x31[i, j]*isigma[j] for j in range(N)] for i in range(N)])
x33 = np.dot(x3, vt)
x4 = np.dot(x33, rot)
x4 = x33
x5_sqrt = x5 + np.dot(np.identity(N)-(1.0/N)*np.ones([N, N]), x4)

afin_sqrt = np.dot(a, x5_sqrt)
