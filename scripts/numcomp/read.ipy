# Numcomp: Numerical comparison for different methods

import os
import matplotlib as mpl
import numpy as np
import exceptions
from mypackage.plot import plotfunctions as pf
from mypackage.plot import plotarrays as pa
from mypackage.run import runmodule as rm
import pandas as pd
import scipy as sp
from scipy import special
from scipy import stats


is_1000 = True

# Methods used in the comparison
which_methods = [0,1,2,3,4,5,6]
names_methods = [pa.names_methods1000[which_methods[i]] if is_1000 
                 else pa.names_methods[which_methods[i]] 
                 for i in range(len(which_methods))]

# Ensemble sizes to produce
which_enssizes = [50,70,100,250] if is_1000 else [50,70,100,250,500,1000,2000]
#Possible [50,70,100,250,500,1000,2000]

# Numbers of synthetic studies
ns_syn_studies = [1,10,100] if is_1000 else [1,10]

# Number of comparisons
n_comparisons = 1000

# Comparison Switch (Only for n_syn >1) "ttest", "gauss"
method = "gauss"

# Confidence Level (Gaussian difference)
cl = 0.95
# cl = 0.5 + 0.5*sp.special.erf( 1.5/np.sqrt(2) )
# P-value (Ttest)
pval = 0.05

# Output names
probsout = "probs1000" if is_1000 else "probs"
setupindsout = "setupinds1000" if is_1000 else "setupinds"
which_methodsout = "which_methods1000" if is_1000 else "which_methods"
names_methodsout = "names_methods1000" if is_1000 else "names_methods"

# n_syn: number of synthetic studies
for n_syn in ns_syn_studies:
    
    # Output Directory
    if n_syn == 1:
        outdir = 'output/numcomp/npy/single/'
    elif method=="ttest":
        outdir = 'output/numcomp/npy/ttest/'
    elif method=="gauss":
        outdir = 'output/numcomp/npy/gaussian/'
    else:
        raise exceptions.RuntimeError("Variable method should be ttest or gauss.")

    #Number of methods * number of ensemble sizes = number of setups
    num_setups = pa.num_jobs1000 if is_1000 else pa.num_jobs
    #Dates
    dates = pa.dates1000 if is_1000 else pa.dates
    #Letters
    letters = pa.letters1000 if is_1000 else pa.letters
    #Number of runs
    sizes = pa.sizes1000 if is_1000 else pa.sizes                          

    # Final residuals
    res = np.zeros([num_setups,1000]) if is_1000 else np.zeros([num_setups,100])
    for i in range(num_setups):
        res[i,0:sizes[i]] = np.load('output/dists/endres_'+dates[i]+'_'+letters[i]+'.npy')  


    # Iterate over ensemble sizes
    for enssize in which_enssizes:

        print enssize
        print '------------------------------------'

        # Flat indices for the setup
        if is_1000:
            setupinds = [(0+i*4 if enssize==50 else 
                         (1+i*4 if enssize==70 else
                          (2+i*4 if enssize==100 else 
                           (3+i*4 if enssize==250 else -1))))
                        for i in which_methods]
        else:
            setupinds = [(0+i*7 if enssize==50 else 
                         (1+i*7 if enssize==70 else
                          (2+i*7 if enssize==100 else
                           (3+i*7 if enssize==250 else 
                            (4+i*7 if enssize==500 else
                             (5+i*7 if enssize==1000 else
                              (6+i*7 if enssize==2000 else -1))))))) 
                        for i in which_methods]

        probs = np.zeros([len(setupinds),len(setupinds),3])
        # DOCUMENTATION:
        # -------------------------------------------------
        # probs[i,j,0] : Probability that method i is better
        # probs[i,j,1] : Probability that methods are equal
        # probs[i,j,2] : Probability that method j is better

        for ii,ri in enumerate(setupinds):
            for ij,rj in enumerate(setupinds):

                #Every pair only once (symmetry)
                if rj < ri:                      
                    continue
                
                # Residual arrays for each method
                resi = res[ri,0:sizes[ri]]
                resj = res[rj,0:sizes[rj]]

                if [n_syn,n_syn] >= [sizes[ri],sizes[rj]]:
                    #Only one comparison if n_syn is at least equal to one of
                    #the sizes
                    n_comparisons = 1         
                                              
                ni = 0                        #...i better
                ne = 0                        #...equal
                nj = 0                        #...j better

                # Iterate number of comparisons
                for i in range(n_comparisons):

                    # Random order
                    intsi = np.random.permutation(np.arange(sizes[ri]))[0:n_syn]
                    intsj = np.random.permutation(np.arange(sizes[rj]))[0:n_syn]
                    resmixi = resi[intsi]
                    resmixj = resj[intsj]

                    # Single run
                    if n_syn == 1:
                        if resmixi[0] < resmixj[0]:    
                            ni = ni + 1
                        elif resmixi[0] > resmixj[0]:  
                            nj = nj + 1
                        else:    #It actually happens...
                            ne = ne + 1

                    # T-Test
                    elif method=="ttest":
                        tv,pv = sp.stats.ttest_ind(resmixi,resmixj,equal_var = False)
                        if pv < pval:     #Significant difference
                            if tv < 0:    
                                ni = ni+1
                            else:         
                                nj = nj+1
                        else:             #No significant difference
                            ne = ne+1

                    # Gaussian difference
                    elif method=="gauss":
                        # Means
                        mi = np.mean(resmixi)
                        mj = np.mean(resmixj)
                        # Mean Standard deviations
                        si = np.std(resmixi)/np.sqrt(resmixi.size)
                        sj = np.std(resmixj)/np.sqrt(resmixj.size)

                        # Mean difference and stdev of mean difference
                        m = mj-mi
                        s = np.sqrt(si*si + sj*sj)

                        # Probability bigger than zero
                        pcl = 0.5 + 0.5*sp.special.erf(m/(s*np.sqrt(2)))

                        if pcl > cl:     #i better
                            ni = ni + 1
                        elif pcl < 1-cl:   #j better
                            nj = nj + 1
                        else:    # No significant difference
                            ne = ne+1
                            
                # Output probabilities
                pi = float(ni)/float(ni+ne+nj)       # i better
                pe = float(ne)/float(ni+ne+nj)       # equal
                pj = float(nj)/float(ni+ne+nj)       # j better

                probs[ii,ij,0] = pi
                probs[ii,ij,1] = pe
                probs[ii,ij,2] = pj

                probs[ij,ii,0] = pj
                probs[ij,ii,1] = pe
                probs[ij,ii,2] = pi

        # Output: Probabilities/Flat indices
        np.save(outdir+probsout+'_'+str(n_syn).zfill(4)+'_'+str(enssize).zfill(4),probs)
        np.save(outdir+setupindsout+'_'+str(n_syn).zfill(4)+'_'+str(enssize).zfill(4),setupinds)

    # Output: Which methods were used: Integers and names
    np.save(outdir+which_methodsout+'_'+str(n_syn).zfill(4),which_methods)    
    np.save(outdir+names_methodsout+'_'+str(n_syn).zfill(4),names_methods)    
