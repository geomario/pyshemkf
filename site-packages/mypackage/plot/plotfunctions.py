#!/usr/bin/python

# Operating system commands
import os
import exceptions

import numpy as np
import matplotlib as mpl
import matplotlib.cm as cm

import vtk
from vtk.util.numpy_support import vtk_to_numpy

import string

# Paths
python_dir = os.environ['HOME']+'/PythonDir'

alphabet = string.lowercase


###############################################################################
#                                    vtk                                      #
###############################################################################
def my_vtk(fdir, fname, varname):
    """
    Get vtk-reader from filename and varname

    Parameters
    ----------
    fdir : string
        Path to the file. Without '/' at end.

    fname : string
        Name of the file.

    varname: string
        Name of the variable

    Returns
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.
    """

    # Check if scalar variable is in vtk-file
    is_var_in_file(fdir, fname, varname)

    # Prepare vtk-Reader
    vtk_reader = vtk.vtkRectilinearGridReader()  # Reader
    vtk_reader.SetFileName(fdir+'/'+fname)    # Filename
    vtk_reader.SetScalarsName(varname)        # Variable name
    vtk_reader.Update()                       # Refresh

    return vtk_reader


def my_vtk_to_numpy(vtk_reader):
    """
    Read array from vtk_reader and output as numpy array.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    Returns
    ----------
    numpy_array: Numpy array
        Numpy array containing the variable array corresponding to
        the vtk_reader.
    """

    vtk_output = vtk_reader.GetOutput()

    # Grid properties
    grid_dimens = vtk_output.GetDimensions()  # Grid Dimensions
    grid_bounds = vtk_output.GetBounds()      # Grid Bounds

    # Reshape array to grid geometry
    if grid_bounds[0] == 0.0:   # CELLS
        vtk_array = vtk_output.GetCellData().GetArray(0)
        # vtk_to_numpy and reshape
        numpy_array = vtk_to_numpy(vtk_array)
        numpy_array = numpy_array.reshape(
            grid_dimens[0]-1,
            1 if grid_dimens[1] == 1 else grid_dimens[1]-1
        )
    else:                       # POINTS
        vtk_array = vtk_output.GetPointData().GetArray(0)
        # vtk_to_numpy and reshape
        numpy_array = vtk_to_numpy(vtk_array)
        if vtk_reader.GetScalarsName() == 'v':
            numpy_array = numpy_array.reshape(grid_dimens[0], grid_dimens[1],
                                              3)
            numpy_array[:, :, 2] = np.sqrt(numpy_array[:, :, 0]**2
                                           + numpy_array[:, :, 1]**2)
        else:
            numpy_array = numpy_array.reshape(grid_dimens[0], grid_dimens[1])

    return numpy_array


def my_vtk_grid_props(vtk_reader):
    """
    Get grid properties from vtk_reader instance.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    Returns
    ----------
    step_x : float
        For regular grid, stepsize in x-direction.

    step_y : float
        For regular grid, stepsize in y-direction.

    npts_x : float
        Number of cells in x-direction.

    npts_y : float
        Number of cells in y-direction.

    low_m_x : float
        Middle of first x cell

    high_m_x : float
        Middle of last x cell

    low_m_y : float
        Middle of first y cell

    high_m_y : float
        Middle of last y cell

    low_x : float
        Edge of first x cell

    high_x : float
        Edge of last x cell

    low_y : float
        Edge of first y cell

    high_y : float
        Edge of last y cell

    Notes
    ----------
    0: step_x
    1: step_y
    2: npts_x
    3: npts_y
    4: low_m_x - Middle of cells: first x cell
    5: high_m_x - Middle of cells: last x cell
    6: low_m_y - Middle of cells: first y cell
    7: high_m_y - Middle of cells: last y cell
    8: low_x - Edge of cells: first x cell
    9: high_x - Edge of cells: last x cell
    10: low_y - Edge of cells: first y cell
    11: high_y - Edge of cells: last y cell
    """

    vtk_output = vtk_reader.GetOutput()

    # Read attributes of the vtk-Array
    # num_cells = vtk_output.GetNumberOfCells()
    # num_points = vtk_output.GetNumberOfPoints()
    # whole_extent = vtk_output.GetExtent()
    grid_bounds = vtk_output.GetBounds()
    grid_dims = vtk_output.GetDimensions()

    # Grid information
    step_x = (grid_bounds[1]-grid_bounds[0])/(grid_dims[0]-1)
    step_y = (grid_bounds[3]-grid_bounds[2])/(grid_dims[1]-1)
    if grid_bounds[0] == 0.0:     # CELLS
        npts_x = grid_dims[0]-1
        npts_y = grid_dims[1]-1
        low_m_x = grid_bounds[0] + 0.5*step_x
        high_m_x = grid_bounds[1] - 0.5*step_x
        low_m_y = grid_bounds[2] + 0.5*step_y
        high_m_y = grid_bounds[3] - 0.5*step_y
        low_x = grid_bounds[0]
        high_x = grid_bounds[1]
        low_y = grid_bounds[2]
        high_y = grid_bounds[3]
    else:                       # POINTS
        npts_x = grid_dims[0]
        npts_y = grid_dims[1]
        low_m_x = grid_bounds[0]
        high_m_x = grid_bounds[1]
        low_m_y = grid_bounds[2]
        high_m_y = grid_bounds[3]
        low_x = grid_bounds[0] - 0.5*step_x
        high_x = grid_bounds[1] + 0.5*step_x
        low_y = grid_bounds[2] - 0.5*step_y
        high_y = grid_bounds[3] + 0.5*step_y

    return step_x, step_y, \
        npts_x, npts_y, \
        low_m_x, high_m_x, low_m_y, high_m_y, \
        low_x, high_x, low_y, high_y


def make_quiver(vtk_reader, ax):
    """
    Read a field of arrows from vtk-file and insert it in axis.

    Parameters
    ----------
    vtk_reader: vtk Reader instance
        vtk Reader containing information about a vtk-file.

    ax : Axes
        The axes to draw to.

    Returns
    -------
    ax : array
        Axes containing plot.

    Notes
    -------
    Only regular grids supported!
    """
    # Quiver
    vtk_output = vtk_reader.GetOutput()

    # 1:Get Vector quantitiy
    v_vtk = vtk_output.GetPointData().GetArray(1)

    # Get grid properties
    (step_x, step_y, npts_x, npts_y, low_m_x,
     high_m_x, low_m_y, high_m_y) = my_vtk_grid_props(vtk_reader)[:8]

    # Generate regular grid, incl last cell
    x = np.arange(low_m_x, high_m_x+1, step_x)
    y = np.arange(low_m_y, high_m_y+1, step_y)
    X, Y = np.meshgrid(x, y)

    # vtk file to NumPy array
    v = vtk_to_numpy(v_vtk)

    # Vector components reshaped to grid
    vx = v[:, 0].reshape(npts_x, npts_y)
    vy = v[:, 1].reshape(npts_x, npts_y)

    # Arrows to axis
    ax.quiver(X, Y, vx, vy, scale=None)

    return ax


def is_var_in_file(path, fname, var, raise_io_error=1, raise_var_error=1,
                   only_scalar=0, only_vector=0):
    """
    Checks the existence of the file and whether var is a variable
    inside the file. Output: 1 if it is inside, 0 if it is not.
    By default, exceptions are raised if the variable is not inside
    the file.
    """
    # Check existence of file.
    try:
        f = open(path+'/'+fname, 'r')
    except IOError:
        if raise_io_error:
            print('\n' + path + '\n')
            raise
        else:
            return 0

    # Check if variable is SCALAR and in file.
    if not only_vector:
        for line in f:
            if line.find('SCALARS ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS  ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS   ' + var) > -1:
                f.close()
                return 1
            elif line.find('SCALARS    ' + var) > -1:
                f.close()
                return 1
    f.seek(0)
    # Check if variable is VECTOR and in file.
    if not only_scalar:
        for line in f:
            if line.find('VECTORS ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS  ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS   ' + var) > -1:
                f.close()
                return 1
            elif line.find('VECTORS    ' + var) > -1:
                f.close()
                return 1
    if raise_var_error:
        raise exceptions.RuntimeError(var + ' not in ' + fname
                                      + '\n Dir: ' + path)
    else:
        return 0


###############################################################################
#                                   cmap                                      #
###############################################################################
def cmap_discretize(cmap, N):
    """Return a discrete colormap from the continuous colormap cmap.

        cmap: colormap instance, eg. cm.jet.
        N: number of colors.

    Example
        x = resize(arange(100), (5,100))
        djet = cmap_discretize(cm.jet, 5)
        imshow(x, cmap=djet)
    """

    if type(cmap) == str:
        cmap = cm.get_cmap(cmap)
    colors_i = np.concatenate((np.linspace(0, 1., N), (0., 0., 0., 0.)))
    colors_rgba = cmap(colors_i)
    indices = np.linspace(0, 1., N+1)
    cdict = {}
    for ki, key in enumerate(('red', 'green', 'blue')):
        cdict[key] = [(indices[i], colors_rgba[i-1, ki], colors_rgba[i, ki])
                      for i in xrange(N+1)]
    # Return colormap object.
    return mpl.colors.LinearSegmentedColormap(cmap.name + "_%d" % N,
                                              cdict, 1024)
